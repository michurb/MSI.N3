def single_plot(learning_rates, map_sizes, radii, feature_vectors, labels):
    figure_size = (map_sizes[0] + 2, map_sizes[1] + 2)
    fig, ax = plt.subplots(figsize=figure_size)
    som = SOM(input_dim=4, map_size=map_sizes, learning_rate=learning_rates, radius=radii)
    som.train(feature_vectors, epochs=1000)

    visualize_som_2d_colored(som, feature_vectors, labels, map_sizes, ax)
    ax.margins(0.15, 0.15)

    title = f"Learning Rate: {learning_rates}, Size: {map_sizes}, Radius: {radii}"
    ax.set_title(title, fontsize=12)

    # Save the plot to the directory
    # Save the plot to the directory
    filename = f"LR_{learning_rates}_Size_{map_sizes[0]}x{map_sizes[1]}_Radius_{radii}.png"

    plt.show()



Rysowanie graphow

def graphs2(learning_rates, map_sizes, radii, feature_vectors, labels, output_directory):
    for lr in learning_rates:
        for size in map_sizes:
            for r in radii:
                fig, ax = plt.subplots(figsize=(size[0] + 2, size[1] + 2))

                som = SOM(input_dim=4, map_size=size, learning_rate=lr, radius=r)
                som.train(feature_vectors, epochs=10)

                visualize_som_2d_colored(som, feature_vectors, labels, size, ax)
                ax.margins(0.15, 0.15)

                title = f"Learning Rate: {lr}, Size: {size}, Radius: {r}"
                ax.set_title(title, fontsize=12)

                # Save the plot to the directory
                # Save the plot to the directory
                filename = f"LR_{lr}_Size_{size[0]}x{size[1]}_Radius_{r}.png"
                filepath = os.path.join(output_directory, filename)
                plt.savefig(filepath)

                plt.close(fig)  # Close the figure after saving




def graphs1(learning_rates, map_sizes, radii, feature_vectors, output_directory):
    for lr in learning_rates:
        for i, size in enumerate(map_sizes):
            for j, r in enumerate(radii):
                figure_size = (size[0] + 2, size[1] + 2)
                fig, ax = plt.subplots(figsize=figure_size)

                som = SOM(input_dim=4, map_size=size, learning_rate=lr, radius=r)
                som.train(feature_vectors, epochs=10)

                visualize_som_2d_multiple(som, feature_vectors, size, ax)
                ax.margins(0.15, 0.15)

                title = f"Learning Rate: {lr}, Size: {size}, Radius: {r}"
                ax.set_title(title, fontsize=12)

                # Save the plot to the directory
                filename = f"LR_{lr}_Size_{size[0]}x{size[1]}_Radius_{r}.png"
                filepath = os.path.join(output_directory, filename)
                plt.savefig(filepath)

                plt.close(fig)  # Close the figure after saving



def visualize_som_2d_colored(som, data, labels, map_size, ax):
    """
    Visualize the trained SOM with the given data colored based on the given labels.
    """
    colors = {1: 'red',  # Car
              9: 'blue',  # Truck
              'unknown': 'yellow'}

    # Initialize matrix to count cars and trucks in each cell
    cars_count_matrix = np.zeros(map_size)
    trucks_count_matrix = np.zeros(map_size)

    # Count the number of cars and trucks for each SOM cell
    for idx, input_vector in enumerate(data):
        x, y = som._find_winner(input_vector)
        if labels[idx] == 1:
            cars_count_matrix[x, y] += 1
        else:
            trucks_count_matrix[x, y] += 1

    # Plotting the SOM nodes with colors based on the dominant vehicle type
    for i in range(map_size[0]):
        for j in range(map_size[1]):
            cars_count = cars_count_matrix[i, j]
            trucks_count = trucks_count_matrix[i, j]
            if cars_count == 0 and trucks_count == 0:
                color = colors['unknown']
                label = 'Unknown'
            elif cars_count > trucks_count:
                color = colors[1]
                label = f'Car (n={int(cars_count)})'
            else:
                color = colors[9]
                label = f'Truck (n={int(trucks_count)})'

            ax.scatter(i, j, marker='s', s=600, color=color, edgecolors='k', linewidths=2, label=label)

            # Adding Data Points
            intensity = (som.weights[i, j, 0] - 0) / 1
            cmap = plt.cm.viridis
            color = cmap(intensity)
            ax.scatter(i, j, marker='o', s=50, color=color, edgecolors='k', alpha=0.7)

    # Custom legend
    custom_lines = [Line2D([0], [0], color=colors[1], lw=4),
                    Line2D([0], [0], color=colors[9], lw=4),
                    Line2D([0], [0], color=colors['unknown'], lw=4)]
    ax.legend(custom_lines, ['Car', 'Truck', 'Unknown'])

    ax.set_xticks(range(map_size[0]))
    ax.set_yticks(range(map_size[1]))
    ax.grid(True)




def visualize_som_2d_multiple(som, data, map_size, ax, title=""):
    """Visualize the trained SOM with the given data."""
    min_val = np.min(data, axis=0)
    max_val = np.max(data, axis=0)
    cmap = plt.cm.viridis

    title_with_score = f"{title}"

    data_point_added = False
    som_node_added = False

    # Plotting the SOM nodes and circles around them
    for i in range(map_size[0]):
        for j in range(map_size[1]):
            intensity = (som.weights[i, j, 0] - min_val[0]) / (max_val[0] - min_val[0])
            color = cmap(intensity)
            ax.scatter(i, j, marker='s', s=600, color=color, edgecolors='k', linewidths=2,
                       label='SOM Node' if not som_node_added else "")
            circle = plt.Circle((i, j), radius=som.radius, color='r', fill=False)
            ax.add_artist(circle)
            som_node_added = True

    # Plotting the input vectors (data points) with reduced size and increased transparency for better visualization
    for input_vector in data:
        x, y = som._find_winner(input_vector)
        intensity = (input_vector[0] - min_val[0]) / (max_val[0] - min_val[0])
        color = cmap(intensity)
        ax.scatter(x, y, marker='o', s=100, color=color, edgecolors='k', alpha=0.7,
                   label='Data Point' if not data_point_added else "")
        data_point_added = True

    ax.set_title(title_with_score)
    ax.set_xticks(range(map_size[0]))
    ax.set_yticks(range(map_size[1]))
    ax.grid(True)
    ax.legend(loc='upper left', bbox_to_anchor=(-0.2, 1.14))

    # Adding colorbar
    sm = plt.cm.ScalarMappable(cmap=cmap, norm=plt.Normalize(vmin=0, vmax=1))
    sm.set_array([])
    plt.colorbar(sm, ax=ax, orientation='vertical', label='Intensity')



# def compute_silhouette_score(som, data):
#     """Compute silhouette score for the given data using the trained SOM."""
#     cluster_labels = [som._find_winner(vec) for vec in data]
#     cluster_labels = [label[0] * som.map_size[1] + label[1] for label in cluster_labels]
#
#     # Check for the number of unique clusters
#     unique_clusters = len(set(cluster_labels))
#     if unique_clusters < 2 or unique_clusters >= len(data):
#         return -1  # Return a default value if silhouette score can't be computed
#
#     return silhouette_score(data, cluster_labels)


porownania z rgb

def load_and_preprocess_data_rgb():
    """Load CIFAR-10 data and preprocess it to extract car images and their labels."""
    (x_train, y_train), _ = cifar10.load_data()

    # Extracting car images. In CIFAR-10, label 1 corresponds to 'automobile'
    car_indices = np.where((y_train == 1) | (y_train == 9))[0]
    car_images = x_train[car_indices][::100]
    labels = y_train[car_indices][::100]

    return car_images, labels


def extract_features_from_rgb_image(rgb_image):
    """Extracts 4 features from the RGB image: mean and standard deviation of the R, G, and B channels."""
    red_channel = rgb_image[:, :, 0]
    green_channel = rgb_image[:, :, 1]
    blue_channel = rgb_image[:, :, 2]

    features = [
        np.mean(red_channel),
        np.mean(green_channel),
        np.mean(blue_channel),
        np.std(red_channel) + np.std(green_channel) + np.std(blue_channel)  # Sum of std deviations
    ]

    return np.array(features)

    # Usage
car_images, labels = load_and_preprocess_data_rgb()